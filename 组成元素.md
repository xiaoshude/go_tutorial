# 程序的基本组成元素

理解一段程序的通用策略：

divide conquer combine 

把一段 Go 代码拆分后有哪些组成部分呢？

和其他编程语言一样，每个程序都是由以下部分组成：

- 变量储存值 
- 简单表达式通过加减操作合并成大的
- 基本数据类型聚合成复杂数据类型
- 表达式通过 if for 控制执行顺序
- 语句组织成函数用于隔离和复用
- 函数被组织成文件和包

我们分类来看每一部分的组成元素。

## 名称

起名字是一个减轻思考负担的重要技巧。函数、变量、常量、类型等的名称命名规则和 js 没有不同：开头字母或下划线，而且不能是关键字。

go里 25个关键字。

另外还有30多个名称被内置常量、类型和函数占用。如果使用就会覆盖内置声明。后面我们会逐渐遇到。

下面说下不同于 js 的一些地方。

1、包的名字总是由小写字母组成。比如最常用的 fmt 包。
2、驼峰命名，这点和 js 一样。
3、首字母大写，指示声明包外可见（前提是，声明本身不在块级作用域内）。所以，我们使用的包的方法都是大写字母开头的。

## 声明

- 变量声明 var ，等价于 js 中 let
- 常量声明 const ，等价于 const
- 函数声明 func，等价于 function
- 声明类型 type，可以理解为 TS 中的 type，但是不等价。下面详细说下这里。

### 类型

一个变量分为两部分：
1. 值
2. 类型

类型的本质是一个特性集的名字。所以每个类型都携带丰富信息：
- 大小（多少位）
- 如何解释内存的 01 数据
- 能进行的合法操作
- 关联了哪些方法

JS 本身没有自定义类型的能力，TS 提供自定义类型和编译时校验。
这里对比下 TS 的类型和 Go 的类型。

1. ts 是鸭子类型，只要结构一致，就认为是相同的类型，可以互相赋值。

[下面的例子](https://www.typescriptlang.org/play?#code/PTAEHUFMBsGMHsC2lQBd5oBYoCoE8AHSAZVgCcBLA1UABWgEM8BzM+AVwDsATAGiwoBnUENANQAd0gAjQRVSQAUCEmYKsTKGYUAbpGF4OY0BoadYKdJMoL+gzAzIoz3UNEiPOofEVKVqAHSKymAAmkYI7NCuqGqcANag8ABmIjQUXrFOKBJMggBcISGgoAC0oACCoASMFmgY7p7ehCTkVOle4jUMdRLYTqCc8LEZzCZmoNJODPHFZZXVtZYYkAAeRJTInDQS8po+rf40gnjbDKv8LqD2jpbYoACqAEoAMsK7sUmxkGSCc+VVQQuaTwVb1UBrDYULY7PagbgUZLJH6QbYmJAECjuMigZEMVDsJzCFLNXxtajBBCcQQ0MwAUVWDEQNUgADVHBQGNJ3KAALygABEAAkYNAMOB4GRogLFFTBPB3AExcwABT0xnM9zsyhc9wASmCKhwDQ8ZC8iElzhB7Bo3zcZmY7AYzEg-Fg0HUiS58D0Ii8AoZTJZggFSRxAvADlQAHJhAA5SASAVBFQAeW+ZF2gldWkgx1QjgUrmkeFATgtOlGWH0KAQiBhwiudokkuiIgMHBx3RYbC43CCJUUqBaxn5AG9UPlBuxENIfgBfIcj6R80ATqecGdzsiLxTuGiwKficeT0AARkX+-hU5XJ6nF+Crn5sGCQA
)

```js
type a = {t: number}
type b = {t: number}

let c: a = {t: 1}
let d: b = {t: 1}
// 这样是允许的
d = c
```

js 这样的做的是为了兼容js动态特性。

go 中不是这这样，比如

```go
type celsius float64
type fahrenheit float64
```

虽然上面两个自定义类型底层类型都是 float64，但他们不同的名字指示了两种类型的不兼容。这是一个很有用的特性，可以进一步切分基本类型以便表达不同的语义。

2. 类型转换

js 中内置类型的构造函数本身也承担着类型转换的作用，比如：

```js
String(1)
// output '1'
```

在 go 中也类似，每一个自定义类型本身也是类型转换函数。

```go
package main

import (
  "fmt"
)

func main() {
  i := string(65)
  fmt.Println(i)
}
//output "A"
```

但是结果可能出乎意料，为什么不是 "65"。

*类型转换并不改变内存数据，只是换一种方式解释数据。*

记住这一重要原则。

至于如何按照我们设想的方式转换，在讲到基本数据类型时会详细说，这里先略过。

3. ts 中的interface 和 type 同为关键字，多数情况下是可以互换的：

```ts
type a = 
```

